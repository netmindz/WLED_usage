<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WLED Usage Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .error {
            color: #d32f2f;
            text-align: center;
            padding: 20px;
            background-color: #ffebee;
            border-radius: 4px;
            margin: 20px 0;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        .tooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
        }
        
        .chart-section {
            margin: 40px 0;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fafafa;
        }
        
        .chart-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }
        
        #version-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #chip-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #matrix-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #flash-size-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #psram-size-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #release-name-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #led-count-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #upgrade-vs-installation-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #version-over-time-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        #running-versions-chart {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        
        .axis-label {
            font-size: 12px;
            fill: #666;
        }
        
        .pie-slice {
            stroke: white;
            stroke-width: 2px;
            transition: opacity 0.3s;
        }
        
        .pie-slice:hover {
            opacity: 0.8;
        }
        
        .pie-label {
            font-size: 12px;
            fill: #333;
            pointer-events: none;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
            gap: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 13px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WLED Usage Dashboard</h1>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by Version</div>
            <div id="version-loading" class="loading">Loading version data...</div>
            <div id="version-error" class="error" style="display: none;"></div>
            <div id="version-chart"></div>
            <div id="version-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by Chip</div>
            <div id="chip-loading" class="loading">Loading chip data...</div>
            <div id="chip-error" class="error" style="display: none;"></div>
            <div id="chip-chart"></div>
            <div id="chip-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by Matrix</div>
            <div id="matrix-loading" class="loading">Loading matrix data...</div>
            <div id="matrix-error" class="error" style="display: none;"></div>
            <div id="matrix-chart"></div>
            <div id="matrix-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by Flash Size</div>
            <div id="flash-size-loading" class="loading">Loading flash size data...</div>
            <div id="flash-size-error" class="error" style="display: none;"></div>
            <div id="flash-size-chart"></div>
            <div id="flash-size-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by PSRAM Size</div>
            <div id="psram-size-loading" class="loading">Loading PSRAM size data...</div>
            <div id="psram-size-error" class="error" style="display: none;"></div>
            <div id="psram-size-chart"></div>
            <div id="psram-size-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by Release Name</div>
            <div id="release-name-loading" class="loading">Loading release name data...</div>
            <div id="release-name-error" class="error" style="display: none;"></div>
            <div id="release-name-chart"></div>
            <div id="release-name-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Device Distribution by LED Count</div>
            <div id="led-count-loading" class="loading">Loading LED count data...</div>
            <div id="led-count-error" class="error" style="display: none;"></div>
            <div id="led-count-chart"></div>
            <div id="led-count-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Update Events - Upgrade New vs Installations (Last 3 Months)</div>
            <div id="upgrade-vs-installation-loading" class="loading">Loading upgrade vs installation data...</div>
            <div id="upgrade-vs-installation-error" class="error" style="display: none;"></div>
            <div id="upgrade-vs-installation-chart"></div>
            <div id="upgrade-vs-installation-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">Version Events Over Time (Last 3 Months)</div>
            <div id="version-over-time-loading" class="loading">Loading version over time data...</div>
            <div id="version-over-time-error" class="error" style="display: none;"></div>
            <div id="version-over-time-chart"></div>
            <div id="version-over-time-legend" class="legend"></div>
        </div>
        
        <div class="chart-section">
            <div class="chart-title">WIP - broken  - Running Versions (Last 3 Months)</div>
            <div id="running-versions-loading" class="loading">Loading running versions data...</div>
            <div id="running-versions-error" class="error" style="display: none;"></div>
            <div id="running-versions-chart"></div>
            <div id="running-versions-legend" class="legend"></div>
        </div>
        
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        // Tooltip
        const tooltip = d3.select("#tooltip");
        
        // Color scale for pie chart
        const colorScale = d3.scaleOrdinal(d3.schemeTableau10);
        
        // Fetch and display version data
        fetch('/api/stats/version')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('version-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('version-error').textContent = 'No version data available';
                    document.getElementById('version-error').style.display = 'block';
                    return;
                }
                
                // Create pie chart
                createPieChart(data);
            })
            .catch(error => {
                console.error('Error fetching version data:', error);
                document.getElementById('version-loading').style.display = 'none';
                document.getElementById('version-error').textContent = 'Error loading version data: ' + error.message;
                document.getElementById('version-error').style.display = 'block';
            });
        
        function createPieChart(data) {
            // Limit to top 10 versions for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more versions, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({version: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#version-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.version}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#version-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.version} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display chip data
        fetch('/api/stats/chip')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('chip-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('chip-error').textContent = 'No chip data available';
                    document.getElementById('chip-error').style.display = 'block';
                    return;
                }
                
                // Create chip pie chart
                createChipPieChart(data);
            })
            .catch(error => {
                console.error('Error fetching chip data:', error);
                document.getElementById('chip-loading').style.display = 'none';
                document.getElementById('chip-error').textContent = 'Error loading chip data: ' + error.message;
                document.getElementById('chip-error').style.display = 'block';
            });
        
        function createChipPieChart(data) {
            // Limit to top 10 chips for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more chips, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({chip: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#chip-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.chip}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#chip-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.chip} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display matrix data
        fetch('/api/stats/matrix')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('matrix-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('matrix-error').textContent = 'No matrix data available';
                    document.getElementById('matrix-error').style.display = 'block';
                    return;
                }
                
                // Create matrix pie chart
                createMatrixPieChart(data);
            })
            .catch(error => {
                console.error('Error fetching matrix data:', error);
                document.getElementById('matrix-loading').style.display = 'none';
                document.getElementById('matrix-error').textContent = 'Error loading matrix data: ' + error.message;
                document.getElementById('matrix-error').style.display = 'block';
            });
        
        function createMatrixPieChart(data) {
            // Convert boolean to readable labels
            const topData = data.map(d => ({
                label: d.isMatrix ? 'Matrix' : 'Non-Matrix',
                deviceCount: d.deviceCount
            }));
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#matrix-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.label}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#matrix-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.label} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display flash size data
        fetch('/api/stats/flash-size')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('flash-size-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('flash-size-error').textContent = 'No flash size data available';
                    document.getElementById('flash-size-error').style.display = 'block';
                    return;
                }
                
                // Create flash size pie chart
                createFlashSizePieChart(data);
            })
            .catch(error => {
                console.error('Error fetching flash size data:', error);
                document.getElementById('flash-size-loading').style.display = 'none';
                document.getElementById('flash-size-error').textContent = 'Error loading flash size data: ' + error.message;
                document.getElementById('flash-size-error').style.display = 'block';
            });
        
        function createFlashSizePieChart(data) {
            // Limit to top 10 flash sizes for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more flash sizes, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({flashSize: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#flash-size-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.flashSize}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#flash-size-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.flashSize} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display psram size data
        fetch('/api/stats/psram-size')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('psram-size-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('psram-size-error').textContent = 'No PSRAM size data available';
                    document.getElementById('psram-size-error').style.display = 'block';
                    return;
                }
                
                // Create psram size pie chart
                createPsramSizePieChart(data);
            })
            .catch(error => {
                console.error('Error fetching PSRAM size data:', error);
                document.getElementById('psram-size-loading').style.display = 'none';
                document.getElementById('psram-size-error').textContent = 'Error loading PSRAM size data: ' + error.message;
                document.getElementById('psram-size-error').style.display = 'block';
            });
        
        function createPsramSizePieChart(data) {
            // Limit to top 10 psram sizes for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more psram sizes, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({psramSize: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#psram-size-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.psramSize}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#psram-size-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.psramSize} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display release name data
        fetch('/api/stats/release-name')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('release-name-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('release-name-error').textContent = 'No release name data available';
                    document.getElementById('release-name-error').style.display = 'block';
                    return;
                }
                
                // Create release name pie chart
                createReleaseNamePieChart(data);
            })
            .catch(error => {
                console.error('Error fetching release name data:', error);
                document.getElementById('release-name-loading').style.display = 'none';
                document.getElementById('release-name-error').textContent = 'Error loading release name data: ' + error.message;
                document.getElementById('release-name-error').style.display = 'block';
            });
        
        function createReleaseNamePieChart(data) {
            // Limit to top 10 release names for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more release names, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({releaseName: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#release-name-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.releaseName}</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#release-name-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.releaseName} (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display LED count range data
        fetch('/api/stats/led-count')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('led-count-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('led-count-error').textContent = 'No LED count data available';
                    document.getElementById('led-count-error').style.display = 'block';
                    return;
                }
                
                // Create LED count pie chart
                createLedCountPieChart(data);
            })
            .catch(error => {
                console.error('Error fetching LED count data:', error);
                document.getElementById('led-count-loading').style.display = 'none';
                document.getElementById('led-count-error').textContent = 'Error loading LED count data: ' + error.message;
                document.getElementById('led-count-error').style.display = 'block';
            });
        
        function createLedCountPieChart(data) {
            // Limit to top 10 ranges for better visualization
            const topData = data.slice(0, 10);
            
            // If there are more ranges, group the rest as "Others"
            if (data.length > 10) {
                const othersCount = data.slice(10).reduce((sum, d) => sum + d.deviceCount, 0);
                if (othersCount > 0) {
                    topData.push({range: 'Others', deviceCount: othersCount});
                }
            }
            
            const pieWidth = 400;
            const pieHeight = 400;
            const radius = Math.min(pieWidth, pieHeight) / 2;
            
            // Create SVG
            const svg = d3.select("#led-count-chart")
                .append("svg")
                .attr("width", pieWidth)
                .attr("height", pieHeight)
                .append("g")
                .attr("transform", `translate(${pieWidth / 2},${pieHeight / 2})`);
            
            // Create pie layout
            const pie = d3.pie()
                .value(d => d.deviceCount)
                .sort(null);
            
            // Create arc
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius - 10);
            
            // Create slices
            const slices = svg.selectAll(".pie-slice")
                .data(pie(topData))
                .enter()
                .append("g")
                .attr("class", "slice");
            
            slices.append("path")
                .attr("class", "pie-slice")
                .attr("d", arc)
                .attr("fill", (d, i) => colorScale(i))
                .on("mouseover", function(event, d) {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100).toFixed(1);
                    tooltip.style("opacity", 1)
                        .html(`<strong>${d.data.range} LEDs</strong><br/>Devices: ${d.data.deviceCount.toLocaleString()}<br/>Percentage: ${percentage}%`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("opacity", 0);
                });
            
            // Add percentage labels on slices
            slices.append("text")
                .attr("class", "pie-label")
                .attr("transform", d => {
                    const pos = arc.centroid(d);
                    return `translate(${pos})`;
                })
                .attr("text-anchor", "middle")
                .style("fill", "white")
                .style("font-weight", "bold")
                .text(d => {
                    const percentage = ((d.data.deviceCount / d3.sum(topData, d => d.deviceCount)) * 100);
                    return percentage > 5 ? `${percentage.toFixed(1)}%` : '';
                });
            
            // Create legend
            const legend = d3.select("#led-count-legend");
            topData.forEach((d, i) => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(i));
                
                item.append("span")
                    .text(`${d.range} LEDs (${d.deviceCount.toLocaleString()})`);
            });
        }
        
        // Fetch and display upgrade vs installation data
        fetch('/api/stats/upgrade-vs-installation')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('upgrade-vs-installation-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('upgrade-vs-installation-error').textContent = 'No upgrade vs installation data available';
                    document.getElementById('upgrade-vs-installation-error').style.display = 'block';
                    return;
                }
                
                createUpgradeVsInstallationChart(data);
            })
            .catch(error => {
                console.error('Error fetching upgrade vs installation data:', error);
                document.getElementById('upgrade-vs-installation-loading').style.display = 'none';
                document.getElementById('upgrade-vs-installation-error').textContent = 'Error loading upgrade vs installation data: ' + error.message;
                document.getElementById('upgrade-vs-installation-error').style.display = 'block';
            });
        
        function createUpgradeVsInstallationChart(data) {
            const margin = {top: 20, right: 30, bottom: 50, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const parseDate = d3.timeParse("%Y-%m-%d");
            const formatDate = d3.timeFormat("%b %d");
            
            const chartData = data.map(d => ({
                date: parseDate(d.week),
                upgrades: d.upgrades,
                newInstallations: d.newInstallations
            }));
            
            const keys = ["upgrades", "newInstallations"];
            const labels = {"upgrades": "Upgrades", "newInstallations": "New Installations"};
            const colors = {"upgrades": "#4e79a7", "newInstallations": "#59a14f"};
            
            const stack = d3.stack().keys(keys);
            const stackedData = stack(chartData);
            
            const x = d3.scaleTime()
                .domain(d3.extent(chartData, d => d.date))
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(stackedData, layer => d3.max(layer, d => d[1]))])
                .nice()
                .range([height, 0]);
            
            const svg = d3.select("#upgrade-vs-installation-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const area = d3.area()
                .x(d => x(d.data.date))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));
            
            const line = d3.line()
                .x(d => x(d.data.date))
                .y(d => y(d[1]));
            
            svg.selectAll(".layer")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "layer")
                .attr("d", area)
                .attr("fill", d => colors[d.key])
                .attr("opacity", 0.6);
            
            svg.selectAll(".line")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("d", line)
                .attr("fill", "none")
                .attr("stroke", d => colors[d.key])
                .attr("stroke-width", 2);
            
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(d3.timeWeek.every(1)).tickFormat(formatDate))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end")
                .attr("class", "axis-label");
            
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5))
                .selectAll("text")
                .attr("class", "axis-label");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Week");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 15)
                .attr("x", -height / 2)
                .text("Count");
            
            // Add tooltip interaction
            const bisect = d3.bisector(d => d.date).left;
            
            const focusGroup = svg.append("g")
                .style("display", "none");
            
            focusGroup.append("line")
                .attr("class", "focus-line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "#666")
                .attr("stroke-dasharray", "3,3");
            
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mouseover", () => focusGroup.style("display", null))
                .on("mouseout", () => {
                    focusGroup.style("display", "none");
                    tooltip.style("opacity", 0);
                })
                .on("mousemove", function(event) {
                    const x0 = x.invert(d3.pointer(event)[0]);
                    const i = bisect(chartData, x0, 1);
                    const d0 = chartData[i - 1];
                    const d1 = chartData[i];
                    if (!d0) return;
                    const d = (d1 && (x0 - d0.date > d1.date - x0)) ? d1 : d0;
                    
                    focusGroup.select(".focus-line")
                        .attr("x1", x(d.date))
                        .attr("x2", x(d.date));
                    
                    tooltip.style("opacity", 1)
                        .html(`<strong>Week of ${formatDate(d.date)}</strong><br/>Upgrades: ${d.upgrades.toLocaleString()}<br/>New Installations: ${d.newInstallations.toLocaleString()}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                });
            
            // Create legend
            const legend = d3.select("#upgrade-vs-installation-legend");
            keys.forEach(key => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colors[key]);
                
                const total = chartData.reduce((sum, d) => sum + d[key], 0);
                item.append("span")
                    .text(`${labels[key]} (${total.toLocaleString()} total)`);
            });
        }
        
        // Fetch and display version over time data
        fetch('/api/stats/version-over-time')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('version-over-time-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('version-over-time-error').textContent = 'No version over time data available';
                    document.getElementById('version-over-time-error').style.display = 'block';
                    return;
                }
                
                createVersionOverTimeChart(data);
            })
            .catch(error => {
                console.error('Error fetching version over time data:', error);
                document.getElementById('version-over-time-loading').style.display = 'none';
                document.getElementById('version-over-time-error').textContent = 'Error loading version over time data: ' + error.message;
                document.getElementById('version-over-time-error').style.display = 'block';
            });
        
        function createVersionOverTimeChart(data) {
            const margin = {top: 20, right: 30, bottom: 50, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const parseDate = d3.timeParse("%Y-%m-%d");
            const formatDate = d3.timeFormat("%b %d");
            
            // Get unique versions and weeks
            const versions = [...new Set(data.map(d => d.version))];
            const weeks = [...new Set(data.map(d => d.week))].sort();
            
            // Pivot data: each row is a week with a property per version
            const pivoted = weeks.map(week => {
                const row = { date: parseDate(week) };
                versions.forEach(v => { row[v] = 0; });
                data.filter(d => d.week === week).forEach(d => {
                    row[d.version] = d.count;
                });
                return row;
            });
            
            const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(versions);
            
            const stack = d3.stack().keys(versions);
            const stackedData = stack(pivoted);
            
            const x = d3.scaleTime()
                .domain(d3.extent(pivoted, d => d.date))
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(stackedData, layer => d3.max(layer, d => d[1]))])
                .nice()
                .range([height, 0]);
            
            const svg = d3.select("#version-over-time-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const area = d3.area()
                .x(d => x(d.data.date))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));
            
            const line = d3.line()
                .x(d => x(d.data.date))
                .y(d => y(d[1]));
            
            svg.selectAll(".layer")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "layer")
                .attr("d", area)
                .attr("fill", d => colorScale(d.key))
                .attr("opacity", 0.6);
            
            svg.selectAll(".line")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("d", line)
                .attr("fill", "none")
                .attr("stroke", d => colorScale(d.key))
                .attr("stroke-width", 2);
            
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(d3.timeWeek.every(1)).tickFormat(formatDate))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end")
                .attr("class", "axis-label");
            
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5))
                .selectAll("text")
                .attr("class", "axis-label");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Week");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 15)
                .attr("x", -height / 2)
                .text("Count");
            
            // Add tooltip interaction
            const bisect = d3.bisector(d => d.date).left;
            
            const focusGroup = svg.append("g")
                .style("display", "none");
            
            focusGroup.append("line")
                .attr("class", "focus-line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "#666")
                .attr("stroke-dasharray", "3,3");
            
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mouseover", () => focusGroup.style("display", null))
                .on("mouseout", () => {
                    focusGroup.style("display", "none");
                    tooltip.style("opacity", 0);
                })
                .on("mousemove", function(event) {
                    const x0 = x.invert(d3.pointer(event)[0]);
                    const i = bisect(pivoted, x0, 1);
                    const d0 = pivoted[i - 1];
                    const d1 = pivoted[i];
                    if (!d0) return;
                    const d = (d1 && (x0 - d0.date > d1.date - x0)) ? d1 : d0;
                    
                    focusGroup.select(".focus-line")
                        .attr("x1", x(d.date))
                        .attr("x2", x(d.date));
                    
                    let tooltipHtml = `<strong>Week of ${formatDate(d.date)}</strong>`;
                    versions.forEach(v => {
                        if (d[v] > 0) {
                            tooltipHtml += `<br/>${v}: ${d[v].toLocaleString()}`;
                        }
                    });
                    
                    tooltip.style("opacity", 1)
                        .html(tooltipHtml)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                });
            
            // Create legend
            const legend = d3.select("#version-over-time-legend");
            versions.forEach(version => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(version));
                
                const total = pivoted.reduce((sum, d) => sum + d[version], 0);
                item.append("span")
                    .text(`${version} (${total.toLocaleString()} total)`);
            });
        }
        
        // Fetch and display running versions data
        fetch('/api/stats/running-versions')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                document.getElementById('running-versions-loading').style.display = 'none';
                
                if (!data || data.length === 0) {
                    document.getElementById('running-versions-error').textContent = 'No running versions data available';
                    document.getElementById('running-versions-error').style.display = 'block';
                    return;
                }
                
                createRunningVersionsChart(data);
            })
            .catch(error => {
                console.error('Error fetching running versions data:', error);
                document.getElementById('running-versions-loading').style.display = 'none';
                document.getElementById('running-versions-error').textContent = 'Error loading running versions data: ' + error.message;
                document.getElementById('running-versions-error').style.display = 'block';
            });
        
        function createRunningVersionsChart(data) {
            const margin = {top: 20, right: 30, bottom: 50, left: 60};
            const width = 800 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;
            
            const parseDate = d3.timeParse("%Y-%m-%d");
            const formatDate = d3.timeFormat("%b %d");
            
            // Get unique versions and weeks
            const versions = [...new Set(data.map(d => d.version))];
            const weeks = [...new Set(data.map(d => d.week))].sort();
            
            // Pivot data: each row is a week with a property per version
            const pivoted = weeks.map(week => {
                const row = { date: parseDate(week) };
                versions.forEach(v => { row[v] = 0; });
                data.filter(d => d.week === week).forEach(d => {
                    row[d.version] = d.count;
                });
                return row;
            });
            
            const colorScale = d3.scaleOrdinal(d3.schemeTableau10).domain(versions);
            
            const stack = d3.stack().keys(versions);
            const stackedData = stack(pivoted);
            
            const x = d3.scaleTime()
                .domain(d3.extent(pivoted, d => d.date))
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(stackedData, layer => d3.max(layer, d => d[1]))])
                .nice()
                .range([height, 0]);
            
            const svg = d3.select("#running-versions-chart")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const area = d3.area()
                .x(d => x(d.data.date))
                .y0(d => y(d[0]))
                .y1(d => y(d[1]));
            
            const line = d3.line()
                .x(d => x(d.data.date))
                .y(d => y(d[1]));
            
            svg.selectAll(".layer")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "layer")
                .attr("d", area)
                .attr("fill", d => colorScale(d.key))
                .attr("opacity", 0.6);
            
            svg.selectAll(".line")
                .data(stackedData)
                .enter()
                .append("path")
                .attr("class", "line")
                .attr("d", line)
                .attr("fill", "none")
                .attr("stroke", d => colorScale(d.key))
                .attr("stroke-width", 2);
            
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(d3.timeWeek.every(1)).tickFormat(formatDate))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end")
                .attr("class", "axis-label");
            
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5))
                .selectAll("text")
                .attr("class", "axis-label");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 5)
                .text("Week");
            
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 15)
                .attr("x", -height / 2)
                .text("Devices");
            
            // Add tooltip interaction
            const bisect = d3.bisector(d => d.date).left;
            
            const focusGroup = svg.append("g")
                .style("display", "none");
            
            focusGroup.append("line")
                .attr("class", "focus-line")
                .attr("y1", 0)
                .attr("y2", height)
                .attr("stroke", "#666")
                .attr("stroke-dasharray", "3,3");
            
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .on("mouseover", () => focusGroup.style("display", null))
                .on("mouseout", () => {
                    focusGroup.style("display", "none");
                    tooltip.style("opacity", 0);
                })
                .on("mousemove", function(event) {
                    const x0 = x.invert(d3.pointer(event)[0]);
                    const i = bisect(pivoted, x0, 1);
                    const d0 = pivoted[i - 1];
                    const d1 = pivoted[i];
                    if (!d0) return;
                    const d = (d1 && (x0 - d0.date > d1.date - x0)) ? d1 : d0;
                    
                    focusGroup.select(".focus-line")
                        .attr("x1", x(d.date))
                        .attr("x2", x(d.date));
                    
                    let tooltipHtml = `<strong>Week of ${formatDate(d.date)}</strong>`;
                    versions.forEach(v => {
                        if (d[v] > 0) {
                            tooltipHtml += `<br/>${v}: ${d[v].toLocaleString()}`;
                        }
                    });
                    
                    tooltip.style("opacity", 1)
                        .html(tooltipHtml)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                });
            
            // Create legend
            const legend = d3.select("#running-versions-legend");
            versions.forEach(version => {
                const item = legend.append("div")
                    .attr("class", "legend-item");
                
                item.append("div")
                    .attr("class", "legend-color")
                    .style("background-color", colorScale(version));
                
                const lastWeekData = pivoted[pivoted.length - 1];
                item.append("span")
                    .text(`${version} (${(lastWeekData ? lastWeekData[version] : 0).toLocaleString()} devices)`);
            });
        }
        
    </script>
</body>
</html>
